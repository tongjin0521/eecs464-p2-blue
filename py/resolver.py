import os, time
from yaml import safe_load, safe_dump

class Resolver(object):
  """
  The resolver class implements a persistent two-way mapping,
  typically between strings.
  
  Persistence is ensured by using a YAML file to store the mapping
  
  Resolver maps both keys to values and values to keys.
  
  If asked to map an unknown key or value, the code treats this
  as a value and auto-generates a key using a hash function.
  
  EXAMPLE OF USE:
    >>> r = Resolver("parrot.yml")
    >>> r.get('parrot','is dead')
    'is dead'
    >>> r['met'] = 'its maker'
    >>> r['met']
    'its maker'
    >>> r.save()
    >>> r2 = Resolver("parrot.yml")
    >>> r2['its maker']
    'met'
  """
  def __init__(self,fn):
    """
    Resolve using mapping stored in file named fn
    
    NOTE: the file's directory must be read-write
      Resolver will save temporary files to this directory
    """
    assert type(fn)==str
    self.fn = fn
    self.tbl = {}
    self.itbl = {}
  
  def load( self ):
    """
    Load contents from file storage.
    
    Silently returns if file is not found / inaccessible
    """
    # Check that we can access the file
    try:
      os.stat(self.fn) 
    except OSError:
      # if stat failed, file doesn't exist or access denied
      return      
    # Read file and (re-)format as dictionary
    f = open(self.fn,'r')
    doc = safe_load(f)
    f.close()
    if type(doc) is not dict:
      raise TypeError("File '%s' does not contain a YAML mapping" % self.fn)
    self.tbl = doc
    # Build inverse dict    
    self.itbl = {}
    for k,v in self.tbl.iteritems():
      self.itbl[v] = k

  def put(self,key,val):
    """The obvious"""
    self.tbl[key]=val
    self.itbl[val]=key    
    return self
    
  def _autokey( self, val ):
    """Automatically generate a key for a value"""
    return 'obj%04d' % (abs(hash(val)) % 10000)
    return key
    
  def save( self ):
    """
    Save mapping to a YAML file.
    
    EXAMPLE:
    >>> r = Resolver('spam')
    >>> r['ham']='spam'
    >>> r['banana']='weapon'
    >>> r.save()
    
    ALGORITHM:
    File is first saved to a temporary filename, then the old file
    is removed and the new file renamed (a.k.a. 'safe save')
    """
    # Temp file name
    nfn = self.fn + '~'
    # Write it
    f = open(nfn,'w')
    f.write("# Saved at %s\n" % time.asctime() )
    safe_dump(self.tbl,f,default_style="!")
    f.close()
    # Windows is broken, as if we didn't know...
    if os.name != 'posix':
      print "WARNING: you are using an inferior OS that does not support posix rename semantics"
      print " attempting a workaround..."
      try:
        os.remove(self.fn)
      except OSError:
        # File might not exist. If not writeable, rename will fail
        pass
    # Move new file on top of old
    os.rename(nfn,self.fn)
    
  def __setitem__(self,key,value):
    """
    Set up the two-way mapping key<-->value
    NOTE: this does not automatically save !
    """
    self.put(key,value)
  
  def get( self, key, default=None ):
    """
    Find key/value associated with key. If not found, return default
    """
    r = self.tbl.get(key,default)
    if r is default:
      r = self.itbl.get(key,default)
    return r
    
  def __getitem__(self, key):
    return self.getWithAuto(key)
    
  def getWithAuto(self, key, autokey = None ):
    """
    Find key/value associated with key.
    If not found:
      - Parameter is a value
      - A key is generated by using autokey, or self._autokey(key) if None 
      - The mapping is saved to disk
    """
    if not self.tbl:
      self.load()
    tag = []
    r = self.get(key,tag)
    if r is tag:
      if autokey is None:
        r = self._autokey(key)
      else:
        r = autokey
      self.put(r,key)
      self.save()
    return r
    
    
