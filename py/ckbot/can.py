#!/usr/bin/env python

"""
  The CKBots.can module provides classes used to communicate with other modules
  on a CAN (Controller Area Network) bus using the Robotics Bus Protocol.

  Classes in this module implement the Robotics Bus protocol. It listens for 
  heartbeats, sends and receives Process Messages and can query Object 
  Dictionaries.
 
  Main uses of this module:
  (*) discover modules that are connected on the CANBus
  (*) obtain a Dictionary Object of a module

  The top-level class of this module is Protocol. Typically, users will create
  a Protocol, listen for heartbeats, then query the object dictionary:
    >>> p = Protocol(Bus())
    >>> time.sleep(2)
    >>> p.update()
    0
    >>> print "there is", len(p.heartbeats), "module on the bus."
    there is 1 module on the bus.
    >>> p.request((0xC8, 0x1001, 0x01), 0x01)
    >>> p.request((0xC8, 0x1001, 0xF7), -1)
    >>> while p.update() > 0:
    ...     pass
    >>> p.msgs[(0xC8, 0x1001, 0xF7)][0].payload
    'feedsw\\x00\\x00'
    >>> p.parse('UINT16',p.msgs[(0x07,1007,0x01)].payload)
    >>> p.parse('STRING32',p.msgs[(0x07,1007,0xF7)].payload)
    >>> pm_key = (0xC8, 0x200)
    >>> promise = p.request_pm(pm_key)
    >>> while not promise
    ...   p.update()
    >>> fmt = 'h'
    >>> while len(p.msgs[pm_key]) > 0:
    >>>   val = p.parse(fmt, promise)


  DEPENDENCIES:
  This code uses the libpcan.so library which is the API/driver for the PCAN 
  devices. http://www.peak-system.com/fileadmin/media/linux/index.htm
"""

import struct
import warnings
import os
import time
from ctypes import *

try:    
  import pcan
except StandardError, se:
  print "Could not import pcan.py. Please run pcanopener.py"
  print "Error was:",str(se)
  
import rb

from ckmodule import AbstractNodeAdaptor, AbstractProtocol, PermissionError, AbstractBusError, AbstractProtocolError, AbstractBus, PYCKBOTPATH
from resolver import *
     
# List that encodes debugging features to enable as one or more chars
#  w -- show messages written to the CAN
#  s -- show source code for specialized OD class
#  d -- DummyBus write
# By default, all instances of classed in this module use the module
#  DEBUG as their .DEBUG -- so changing the contents of this list
#  can switch on debugging features at runtime, e.g.
#  >>> DEBUG[:]=['w']
DEBUG=['']

class BusError( AbstractBusError ):
  def __init__(self,code):
    AbstractBusError.__init__(self,"CAN bus error 0x%04x" % code)

class ProtocolError( AbstractProtocolError ):
  def __init__(self,key):
    AbstractProtocolError.__init__(self,"Robotics Bus (CAN) error with key (Nx%02x, 0x%04x, 0x%02x)" % (key[0], key[1], key[2]))

import time
      
class Bus(AbstractBus):
    """
    This concrete class provides all the functionality needed to send and 
    receive messages using the CANbus protocol.

    This module imports pcan which is generated from the PCAN driver header
    files autogenerated by pcanopener.py. Documentation on the driver can be
    found here:
      http://www.peak-system.com/fileadmin/media/linux/index.htm

    Typical usage consists of opening a CANbus and writing a message:
      >>> b = Bus()
      >>> b.open()
      >>> b.write(0x11,(0x11, 0x22, 0x33, 0x44)) 
      0
      >>> b.write(0x1A9, (0x94, 0x11))
      0
      >>> (dword, rdmsg) =  b.read(2000);
      >>> b.close()
    """
    def __init__(self,*args,**kw):
        """
        concrete constructor

        ATTRIBUTES:
          can -- instantiation of a CANIX class 
        """
        AbstractBus.__init__(self,*args,**kw)
        self.can = pcan.CANIX()
        errno = self.can.init()
        if errno != 0:
            raise BusError( errno )
        self.DEBUG = DEBUG
        self.now =0 #!!!

    @classmethod
    def setstruct(cls, fmt, *args):
        return tuple((ord(c) for c in struct.pack(fmt, *args)))

    def close(self):
        """
          close the CANbus
        """
        self.can.close(); 

    def write(self, ID, DATA):
        """
          write a CAN message

          INPUT:
            ID: -- integer -- 11 bit identifier
            DATA: -- tuple of integers -- tuple of data bytes (up to 8)
        """
        MSGTYPE = pcan.MSGTYPE_STANDARD
        msg = pcan.Msg(ID,MSGTYPE,len(DATA),DATA)
        if 'w' in self.DEBUG:
          print "#> TX 0x%04X" % msg.ID, " ".join([ "%02X" % d for d in msg.DATA ]) 
        errno = self.can.write(pointer(msg))
        if errno != 0:
          raise BusError(errno)
        if msg.ID == 0x103:
          now = time.time()
          #!!!print "CAN dt", now-self.now
          self.now = now

    def read(self):
        """
          Read a CAN message. Blocks until a new message arrives or a timeout occurs. The default timeout is 1000ms.
    
          INPUT:
            timeout -- in milliseconds
          OUTPUT:
            rdmsg -- struct or None
        """
        msg = pcan.Msg(0, 0, 0, (0,)*8)
        errno = self.can.read(pointer(msg))
        if errno == pcan.ERR_QRCVEMPTY:
          return None
        elif errno != 0:
          raise BusError(errno)
        if 'r' in self.DEBUG:
          print "#> RX 0x%04X" % msg.ID, " ".join([ "%02X" % d for d in msg.DATA ]) 
        return msg

    @classmethod
    def print_msg(cls, word, rdmsg):
        """ for debugging """
        if word != 32:
            print "word: ", word
            print "ID: ", rdmsg.Msg.ID
            print "length: ", rdmsg.Msg.LEN
            for i in rdmsg.Msg.DATA:
                print "data: ", i
        else:
            print "queue is empty"




def chrs(obj):
    """Treat a ctypes object as a char array"""
    p = cast( pointer(obj), POINTER(c_char * sizeof(obj)) )
    return p[0]

  
class IncompleteMsg(object):
    """
    This concrete class resepresents an incomplete dictionary object. Typically an
    instantiation of this class is used to collect segments and is put on the
    incompletes queue. The incompletes queue lives in the Protocol class and is
    private.
      
    ATTRIBUTES:
      start -- first subindex of segments requested
      end -- last subindex of segments requested. set this to negative if you
        want to read until null like in the case of reading a string.
      timestamp -- time of last segment received
      segments -- list of TPCAN messages that have been received
    """
    def __init__(self, start, end,  timestamp=-1, segments=None):
        self.start = start
        self.end = end
        self.timestamp = timestamp
        self.retries = 0
        if segments == None:
            self.segments = []

    
class Msg(object):
    """ 
    A concrete class representing a completed response to a Robotics Bus 
    Dictionary Object request.

    ATTRIBUTES:
      payload -- partial dictionary object assembled from segments
      timestamp -- time when full dictionary object response is received
      incomplete_msg -- contains individual segments of the dictionary object 
        response
    """
    def __init__(self, incomplete_msg, payload, timestamp):
        self.payload = payload
        self.timestamp = timestamp
        self.incomplete_msg = incomplete_msg
               
class Protocol(AbstractProtocol):
    """
    This concrete class provides all the functionality needed to send and 
    receive messages using the Robotics Bus protocol based on an internal document:
    "The Robotics Bus: Interface Specification", Dec 17, 2004.
    
    A newer document can be found at DOI link: http://dx.doi.org/10.1117/12.571476

    Typically a cluster instantiates a Protocol. Protocol owns a Bus instance.

    Example usage is shown in the module description.
    """
    def __init__(self,bus=None,*args,**kw):
        """
        constructor -- creates dictionaries to organize the different Robotics 
        Bus messages and instantiates a Bus.

        ATTRIBUTES:
          bus -- a bus instance
          heartbeats -- records heartbeats by ID -- stores only the newest 
          heartbeat of a particular ID as (timestamp,data) pairs
          _incomplete_msgs -- dictionary of outstanding incompleted dictionary 
          messages -- the keys denote the address of a segment, the address 
          being a tuple of (node ID, index, subindex). E.g. (0x05, 0x1007, 0xF7)
          denotes node ID 5, index 1007 and subindex F7
          msgs -- dictionary of assembled dictionary messages -- keys consistent
          with  incomplete_msgs
          pmsgs -- dictionary of received process messages -- keys are a tuple of
          (node ID, PM index) e.g. (0x05, 0x100). values are a list of received
          process messages
        """
        AbstractProtocol.__init__(self,*args,**kw)
        if bus is None:
          self.bus = Bus()
        elif type(bus)==type:
          self.bus = bus()
        else:
          self.bus = bus
        self.heartbeats = {}
        self.msgs = {}
        self.pmsgs = {}
        self._incomplete_msgs = {}
        
    def request(self, key, subindex_end, incomplete_msg = None):
        """
        Sends out a dictionary request to ask for the first segment of a 
        dictionary object. This dictionary request message is put on the 
        incompletes queue. To obtain the remaining segments, the client should
        call update() to generate the request message asking for the next 
        segment of this dictionary object.
        
        TODO:
        This method makes sure the module is alive on the CANbus by looking at
        the heartbeats. It also clears any completed messages with the same 
        address if on the completed queue. Warnings will be thrown if any of 
        these events occur.
        
        INPUT: 
          key -- tuple of 3 elements (nid, index, subindex_start): 
             nid -- 7 bit value -- node id 
             index -- 16 bit value -- address of dictionary object
             subindex_start -- 8 bit value -- address of first segment
          subindex_end -- 8 bit value -- address of last segment
          incomplete_msg -- IncompleteMsg -- (optional) if we are appending to 
          previous incomplete object dictionary response
          
        OUTPUT
          promise -- empty list -- gets filled when all segments have been 
            received
        """
        self.read_dict_req_msg(key)
        if incomplete_msg == None:
            incomplete_msg = IncompleteMsg(key[2], subindex_end, time.time()) 
        self._incomplete_msgs[key] = incomplete_msg
        self.msgs[key] = []
        return self.msgs[key] # return promise

    def set(self, key, subindex_end, incomplete_msg = None):
        """
          TODO setting a dictionary object.
        """
        pass

    @classmethod
    def _incr_subindex(cls, key):
        """
        Helper class method to increment the third element of a tuple. This is
        used when incrementing the subindex of a incomplete msg key.
        """
        return (key[0], key[1], key[2]+1)

    @classmethod
    def _set_subindex(cls, key, subindex):
        """
        Helper class method to increment set third element of a tuple. This is
        used when setting the subindex of a incomplete msg key.
        """
        return(key[0], key[1], subindex)

    def generatePNA( self, nid ):
        """
        Create a ProtocolNodeAdaptor for the specified nid
        """
        return ProtocolNodeAdaptor( self, nid )
        
    def _store(self, key, msg):
        """
        Pops the incomplete message with matching key off the _incomplete_msgs 
        and appends the msg to its segments. 

        If the requested end subindex  was set to -1 and the ODO response is 
        complete (it encountered a null string) or if the subindex of the response
        matched the end subindex requested then this message gets put on
        the msgs queue. 

        If it is not complete, the subindex is incremented and
        it gets put back on the _incomplete_msgs queue and the subsequent
        segment is requested.

        INPUTS:
          key -- tuple with 3 elements -- (nid, index, subindex)
          msg -- TPCANMsg -- message received
        """
        the_msg = self._incomplete_msgs.pop(key)
        the_msg.timestamp = time.time() 
        the_msg.segments.append(msg)
        if the_msg.end == -1: #read until null string
            if msg.DATA[7] == 0 or key[2]==254: #if null string encountered or last subindex
                key = Protocol._set_subindex(key, the_msg.start)
                self.msgs[key][:] = [Msg(the_msg, Protocol.collect(the_msg), time.time())]
            else:
                key = Protocol._incr_subindex(key)
                self.request(key, the_msg.end, the_msg) 
        elif the_msg.end > key[2]: #if we have not yet reached requested end subindex 
            key = Protocol._incr_subindex(key)
            self.request(key, the_msg.end, the_msg) 
        else: # we have reached the last subindex
            key = Protocol._set_subindex(key, the_msg.start)
            self.msgs[key][:] = [Msg(the_msg, Protocol.collect(the_msg), time.time())]


    def hintNodes(self,nodes):
        """ (required by superclass)
        """
        pass
      
    def update(self):
        """
        Reads all messages on the CAN bus queue, and sorts them in the 
        heartbeat, process message or incompleted message queue and returns the
        number of oustanding incomplete messages.

        This function also generates the subsequent dictionary request message
        to request the next segment in the dictionary object.

        If it reads a Object Dictionary response message whose key isn't in the
        incomplete message queue it is ignored. Most likely this means someone 
        else is querying this Dictionary Object.

        OUTPUT:
          num_incompletes -- integer -- number of oustanding incompletes.

        """
        msg = self.bus.read()
        while msg is not None:
            #Decode address and payload fields from rdmsg.Msg
            msg_type  = msg.ID&0xF00
            msg_id  = msg.ID&0x0FF
            data = msg.DATA
            if msg_type == rb.RB_HEARTBEAT: #Handle Heartbeats
                self.heartbeats[msg_id&0x0FF] = (time.time(),data)
            elif msg_type == rb.RB_DICT_RESP: #handle OD responses
                #Unpack OD address
                data_packed = struct.pack("<BB", data[2], data[3]) #TODO use chrs function
                index = struct.unpack("<H", data_packed)[0]
                subindex = data[1]
                key = (msg_id, index, subindex)
                if self._incomplete_msgs.has_key(key):#if no matching key, ignore
                    self._store(key, msg)
            elif self.pmsgs.has_key((msg_id, msg_type)): #handle process messages
                self.pmsgs[(msg_id, msg_type)].append(Msg(msg, 
                                                          chrs(data)[:], 
                                                          time.time()))
            msg = self.bus.read() # get next message in message handling loop
        self.clean_incompletes()
        return len(self._incomplete_msgs)


    def clean_incompletes(self, timeout = 0.1, retries = 20):
      """
      Retries another dictionary request of incomplete message if timed out. 
      After several retries puts a ProtocolError in the msgs list.

      INPUT:
        timeout -- how long to wait before sending a retry in milliseconds
        retries -- number of retries
      OUTPUT:
        num_failed -- number of OD requests not received
      """
      num_failed = 0
      for key, inc in self._incomplete_msgs.items():
        if time.time() - inc.timestamp > timeout:
          if inc.retries >= retries:
            the_msg = self._incomplete_msgs.pop(key) 
            key = Protocol._set_subindex(key, the_msg.start)
            self.msgs[key][:] = [Msg(the_msg, [ProtocolError(key)], time.time())]
            num_failed += 1
          else:
            self.read_dict_req_msg(key)
            inc.timestamp = time.time()
            inc.retries += 1
      return num_failed
            

    @classmethod
    def collect(cls, incomplete_msg):
        """
        Collect the data from the segments of an incomplete message and return 
        the assembled payload.

        INPUT:
          segments -- list of TPCan Msgs
        OUTPUT:
          payload -- assembled data from the segments -- little endian
        """
        payload = ''
        for s in incomplete_msg.segments:    # struct.unpack('<h',rdmsg.Msg.DATA[2:4])
            payload += chrs(s.DATA)[4:]

        return payload

    @classmethod
    def pop(cls, fmt, promise): 
      """
      Pops the latest promise off the msgs or pmsgs and parses the payload.
      
      INPUT
        fmt -- character format of the payload -- e.g. 'h'
        promise -- empty list -- gets filled when as process messages are being
          received.

      OUTPUT
        result -- parsed data according to fmt.
      """
      n = struct.calcsize(fmt)
      return struct.unpack(fmt, promise.pop().payload[0:n])[0]

    def read_dict_req_msg(self, key):
        """
        Sends out a dictionary request message to ask for one segment of a 
        dictionary object.

        INPUT:
          key -- tuple of (node id, index, subindex)
        """
        cs = rb.RB_CS_READ
        data_packed = struct.pack("<BBH", cs, key[2], key[1])
        data = struct.unpack(">BBBB", data_packed)
        self.bus.write(rb.RB_DICT_REQ + key[0], data) 

    def set_dict_req_msg(self, key, bytes):
        """
        Sends out a dictionary request message to set the value of one segment 
        of a dictionary object.

        EXAMPLE: set_dict_req_msg ((0xA9,0x1050,0x01),"")

        INPUT:
          key -- tuple of (node id, index, subindex)
          bytes -- value of object encoded as a string
          
          #J use chrs() here? is it more efficient ?
          TODO implement datatypes with length > 4 bytes
        """
        nid, idx, sub = key
        hdr = struct.pack("<BBH", rb.RB_CS_WRITE, sub, idx)
        body = tuple(map(ord,hdr+bytes))
        self.bus.write(rb.RB_DICT_REQ + nid, body )

    def request_pm(self, key):
        """
        Start receiving a certain process message. This method returns an empty list.
        It returns an empty list. call update() repeatedly. This list
        gets filled with process message data.
        INPUT
          key -- tuple of (node, index)
        """
        self.pmsgs[key] = []
        return self.pmsgs[key]

    def send_pm(self, nid, pm_index, fmt, value):
        """
        Sends a process message.

        INPUT:
          nid -- node id
          pm_index -- process message mapping
          fmt -- format
          value -- value to be sent.
        #J update comment
        """
        #DictionaryObject.DTYPES
        bytes = struct.pack(fmt,value)
        body = tuple(map(ord,bytes))
        self.bus.write(pm_index + nid, body )

    def start(self, nid):
        """
        Resets a node using a network management message.

        INPUT:
          nid -- node id
        """
        self.bus.write(0,(rb.RB_CS_START,nid))

    def stop(self, nid):
        """
        Resets a node using a network management message.

        INPUT:
          nid -- node id
        """
        self.bus.write(0,(rb.RB_CS_STOP,nid))


    def reset(self, nid):
        """
        Resets a node using a network management message.

        INPUT:
          nid -- node id
        """
        self.bus.write(0,(rb.RB_CS_RESET,nid))



class DictionaryObject(object):
    """
      This class is used as a struct to represent a Dictionary Object. Attribute
      values are described in the Robotics Bus protocol.
      
      ATTRIBUTES:
        index -- 16 bit value that specifies a particular object that a Robotics
        Bus node makes available over the Bus
        permission -- 0x01: read only, 0x02: write only, 0x03: read write
        data type -- type specificier:  (type, format, name, length in bytes)) 
        description -- string -- a 32 character human readable description
        name -- string -- a concise name    
        nid -- 8 bit node ID (if present) 
    """

    PERM_RO = 0x01
    PERM_WO = 0x02
    PERM_RW = 0x03 

    def __init__(self, index, permission, type, description, name = None, nid = None, pna=None):
        self.index = int(index)
        self.permission = permission
        self.type = type
        self.description = str(description)
        self.name = str(name)
        self.nid = int(nid)
        assert isinstance(pna,ProtocolNodeAdaptor)
        self.pna = pna

    def __repr__(self):
        if self.nid is not None:
          nid = self.nid
        else:
          nid = 0xDEAD
        if self.name is None:
          name = "<None>"
        else:
          name = self.name
        return "<%s at 0x%x is %x:%x '%s'>" %(
          self.__class__.__name__, id(self), nid, self.index, name)
        
    def isReadable( self ):
        return 0!=(self.permission & DictionaryObject.PERM_RO)

    def isWritable( self ):
        return 0!=(self.permission & DictionaryObject.PERM_WO)
        
    def fmt( self ):
      return rb.DTYPES[self.type][1]
      
    def get_sync(self, tic=0.01):
        if not self.isReadable():
          raise PermissionError('Object 0x%04x is not readable' % self.index)
        return self.pna.get_sync( self.index, self.fmt(), tic )
            
    def get_async(self ):
        if not self.isReadable():
          raise PermissionError('Object 0x%04x is not readable' % self.index)
        return self.pna.get_async( self.index )
    
    def async_parse(self, promise):
        return self.pna.async_parse( self.fmt(),promise)

    def set(self, value):
        if not self.isWritable():
          raise PermissionError('Object 0x%04x is not writable' % self.index)
        return self.pna.set( self.index, self.fmt(), value )

class ProtocolNodeAdaptor( AbstractNodeAdaptor ):
  """
  Adaptor class that provides access to object dictionary and process messages
  of a specific node ID.
  """
  def __init__(self, protocol, nid):
    self.p = protocol
    self.nid = nid
  
  def get_typecode( self ):
    """
      Get the module type information.
    """
    typecode_key = (self.nid, 0x1000, 0xF7)
    self.p.request(typecode_key, -1)
    while self.p.update() > 0:
      pass
    pld = self.p.msgs[typecode_key][0].payload 
    if pld and isinstance( pld[0], Exception ): 
      raise pld[0]
    assert(isinstance(pld, str))
    typecode = pld.replace('\x00','')
    return typecode
    
  def get_sync(self, index, fmt, tic=0.01):
    """
      This method gets the value of a object in a module's object 
      dictionary. 
    """
    promise = self.get_async( index )
    while not promise:
        time.sleep(tic)
        self.p.update()
    return self.async_parse(fmt,promise)
  
  @classmethod
  def async_parse(cls, fmt, promise): 
    """
    Parse the result of an asynchronous get operation
    This method is called to complete a get_async() after the promise
    it returned becomes non-empty.
    
    If a communication error occurred, returns the exception object
    INPUTS:
      fmt -- str -- format string for result (see python's struct module)
      promise -- list -- a list returned by get_async
    """
    n = struct.calcsize(fmt)
    data = promise[0].payload
    if data and isinstance(data[0],Exception):
      return data[0]
    return struct.unpack(fmt,data[0:n])[0]

  def get_async(self, index):
    """
      This method gets the value of a 16 bit signed integer variable of a 
      object in a module's object dictionary asynchronously. It returns an
      empty list. call update() repeatedly. Once all segments have been 
      received this empty list is filled with a Msg instance.
    """
    key =(self.nid, index, 0x01)
    self.p.request(key, 0x01) #request description
    return self.p.msgs[key]

  def set(self, index, fmt, value):
    """
      #S update comment 
    """
    key = (self.nid, index, 0x01 )
    bytes = struct.pack(fmt,value)
    self.p.set_dict_req_msg( key, bytes )

  def send_pm(self, pm_index, fmt, value):
    """
    Sends a process message.

    INPUT:
      pm_index -- process message mapping
      fmt -- format string
      value -- value to be sent.
    """
    bytes = struct.pack(fmt,value)
    body = tuple(map(ord,bytes))
    self.p.bus.write(pm_index + self.nid, body )

  def get_od(self,progress = lambda x : None):
    """
    Create a specialized object dictionary subclass for this nid
    """
    od = ObjectDictionary(self.p)
    od.walk(self.nid, progress)
    return od.specialize(self.nid)

  def start(self):
    """
    Resets a node using a network management message.
    """
    self.p.bus.write(0,(rb.RB_CS_START,self.nid))

  def stop(self):
    """
    Resets a node using a network management message.
    """
    self.p.bus.write(0,(rb.RB_CS_STOP,self.nid))

  def reset(self):
    """
    Resets a node using a network management message.
    """
    self.p.bus.write(0,(rb.RB_CS_RESET,self.nid))

class ObjectDictionary(object):
    """
      Concrete class used to create a Object Dictionary (OD).
      
      Typically a Cluster instantiates a ObjectDictionary and Protocol. 

      It can then query a module for all of its Dictionary Objects using the 
      walk() method and stores the Dictionary Objects in index_table. A 
      Dictionary Object is a unit of data that represents a single state or 
      quantity that a module has made accessible to the outside world. 

      To access these Dictionary Objects the specialize() method can be used. It
      returns a dynamics subclass to create convenient names e.g. Position and 
      corresponding methods e.g. getPosition()that can get/set these objects. 

      The convenience names are mapped in od_names.txt and maintained using 
      Resolver.

      EXAMPLE:
      >>> p = Protocol(Bus())
      >>> time.sleep(2)
      >>> p.update()
      0
      >>> nids = p.heartbeats.keys()
      >>> for nid in nids:
      >>>   od = ObjectDictionary(p)
      >>>   od.walk(nid)
      >>>   ods[nid] = od.specialize(nid)
      >>> ods[nids[0]].get_0x1050()
      >>> ods[nids[0]].set_0x1050(9001)

      >>> p1 = ods[nids[0]].get_async_0x1050()
      >>> p2 = ods[nids[0]].get_async_0x1060()
      >>> while not p1 and not p2:
      >>>   time.sleep(0.1) # do some stuff prior to first response
      >>>   od.p.update()
      >>> if p1:
      >>>   print "0x1050 was first, equals", od.val(p1)
      >>> else:
      >>>   print "0x1060 was first, equals", od.val(p2)

    """
    
    def __init__(self, protocol):
        """
        constructor -- creates tables for dictionary objects. The tables contain
        the same dictionary objects, but one can be accessed by index, the other
        by name.

        ATTRIBUTES:
          index_table -- a python dictionary of instantiations of DictionaryObject by index
          name_table -- a python dictionary of instantiations of DictionaryObject by name
        """
        self.index_table = {}
        self.name_table = {}
        self.p = protocol
        self.pna = None
        self.DEBUG = DEBUG

    def _possess( self, other ):
        """ (private)
        Move internal data structure from other instance.
        Used to allow specialized instance to take over duties of
        auto-generated instance
        """
        for attr in ['index_table','name_table','pna']:
          setattr( self, attr, getattr(other,attr))
          setattr( other,attr,None)        
  
    def walk(self, nid, progress=lambda x : None, tic = 0.1):
        """
          Queries node with given node ID (nid) for all its dictionary objects 
          and stores these in the index_table. This method does not fill out the
          names attribute. That is up to the specialize() method.

          INPUT:
            nid -- node ID
            protocol -- instantiation of Protocol
            progress -- function for progress reports
            tic -- time to sleep between calling update 
        """
        #while link_to_next object is not end_of_dictionary:
        #  Generate first key of dictionary object
        #  Request dictionary object with key
        #  while protocol.update() > 0:
        #    pass
        #  create new dictionary object from p.msgs[key]
        #  add this dictionary object to the index_table
        def unpack( key, fmt, slc ):
          pld = self.p.msgs[key][0].payload
          if isinstance( pld[0], Exception ):
            raise pld[0]
          len = struct.calcsize(fmt)
          return struct.unpack(fmt, pld.__getslice__(slc,slc+len))[0]
        progress("Scanning Nx%02x" % nid)
        self.pna = self.p.generatePNA( nid ) 
        index = 0x1000
        self.p.update()
        while index != 0:
          progress("Scanned object 0x%04x" %  index)
          self.p.request((nid, index, 0x00), 0x00) #request permission code and variable type
          self.p.request((nid, index, 0xF7), -1) #request description
          self.p.request((nid, index, 0xFF), 0xFF) # request link to next object       
          while self.p.update() > 0:
            time.sleep(tic)
          permission = unpack((nid, index, 0x00), '<b', 0)
          type = unpack((nid, index, 0x00), '<b', 1)
          description = self.p.msgs[(nid, index, 0xF7)][0].payload
          if description and isinstance(description, str):
            description = description.replace('\x00','') 
          #!!! breaks -- async read without checking for result!
          next_obj = unpack((nid, index, 0xFF), '<h', 0)
          self.index_table[index] = DictionaryObject(
            index=index,
            permission=permission,
            type=type,
            description=description,
            name=None,
            nid=nid,
            pna=self.pna)
          index = next_obj
        progress("Scanning complete")

    def specialize(self, nid, od_names_file = "cfg/od_names.yml", save = False):
        """
          This method returns a dynamic subclass of ObjectDictionary
          which has get/set methods for dictionary objects.

          It loads od_names.yml and updates the dictionary objects with
          their names and creates a name_table. It also generates get/set
          methods for getting/setting the dictionary objects. The name of 
          these methods is get_<name>, for example get_position.
        """
        if self.__class__ != ObjectDictionary:
          raise TypeError,"Only generic ObjectDictionary-s may be specialize()ed"
        global names
        names = Resolver(PYCKBOTPATH+od_names_file)
        # The following class is named after the (unique) id of the creator
        # to ensure that redefinition does not overwrite it.
        cls = 'ObjDict_0x%x' % id(self)   
        src = [
            'class %s ( ObjectDictionary ):' % cls,
            '  def __init__(self,nid):',
            '    self.nid = nid'
            ]
        for i, o in self.index_table.iteritems():
            # index, perm, kind, desc, name = info from object
            attrname = names.getWithAuto('%04x' % i + o.description, '0x%x' % i)
            # ODO can now be registered by name 
            o.name = attrname
            self.name_table[attrname] = o            
            #  getter,setter = appropriate get/set method names for data type kind
            fmt = o.fmt()
            if o.isReadable():
                src += ['  def get_%s( self ): return self.pna.get_sync( 0x%x,"%s" )' % (attrname, i, fmt) ]
                src += ['  def get_async_%s( self ): return self.pna.get_async( 0x%x )' % (attrname, i) ]                
            if o.isWritable():
                src += ['  def set_%s( self, value): return self.pna.set( 0x%x, "%s", value)' % (attrname, i, fmt ) ]
        if 's' in self.DEBUG:
          print "\n##> ".join(src)        
        try:
          exec("\n".join(src))
        except Exception, e:
          print "Source code was:"
          print "\n".join(src)
          raise
        if save:
          names.save()
        newClass = eval(cls)
        sod = newClass(nid)
        sod._possess(self)
        return sod
 
def clusterDict(bus=None,quiet = False):
  """
  Scan the CAN and construct a dictionary of the specialized interfaces
  to the modules on the bus
  """
  if bus is None:
    bus = Bus()
  p = Protocol()
  p.update()
  res = {}
  for nid in p.heartbeats.keys():
    od = ObjectDictionary(p)
    od.walk(nid)
    res[nid] = od.specialize(nid)
  return res

if __name__ == "__main__":
    import doctest
    doctest.testmod()
